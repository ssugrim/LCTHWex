#include<thread>
#include<mutex>
#include<iostream>
#include<functional>
#include<vector>
#include<cstdlib>

/*
 * This is my dummy function. I'll take a mutex as an ARG (instead of the
 * usual global).
 * Note how the mutex is taken by reference
 */
void countto(
        const int i,
        const int tno,
        std::mutex &mut,
        std::vector<int> &rets){

    int j = 0;
    for(; j < i; j++){
        mut.lock();
        std::cout << "Thread" << tno << " " << j << "\n";
        mut.unlock();
    }
    mut.lock();
    rets.push_back(j);
    mut.unlock();
}

int main (){

   //Think of this as a vector of pthread_ts 
   std::vector<std::thread> threads;
   std::vector<int> rets;

   //My only mutex
   std::mutex mut;

   for(int count = 0; count < 100; count ++){
       int r = rand() % 100; // random number from 1 to 100

       threads.emplace_back(countto, r, count, std::ref(mut), std::ref(rets));
       // An implicit call to std::thread THREADOBJNAME(countto, r, count, std::ref(mut));
   }

   for(auto &t: threads){
        t.join();
   }

   for(const auto &i: rets){
       std::cout << "Got " << i << std::endl;
   }

}

